import logging
from aiogram import Router, types, F
from aiogram.filters import CommandStart, Command
from aiogram.utils.markdown import hbold, hlink
from aiogram.enums import ParseMode
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.fsm.context import FSMContext
from datetime import datetime, timedelta, timezone

from app.db.crud import user_crud
from app.ui.keyboards import (
    get_main_menu_keyboard,
    get_onboarding_welcome_keyboard,
    get_onboarding_explanation_keyboard,
    get_onboarding_trial_offer_keyboard,
    get_main_inline_menu_keyboard,
    get_back_to_main_menu_keyboard,
    OnboardingCallback
)
from app.db.models import SubscriptionStatus, UserRole
from app.core.config import settings
from app.states.feedback_states import FeedbackStates

logger = logging.getLogger(__name__)
user_onboarding_router = Router(name="user_onboarding_handlers")

WELCOME_TEXT = """üëã –ü—Ä–∏–≤–µ—Ç! –Ø –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –Ω–∞–≤—ã–∫–æ–≤ –ö–ü–¢-–ø—Å–∏—Ö–æ—Ç–µ—Ä–∞–ø–µ–≤—Ç–æ–≤.

–ó–¥–µ—Å—å —Ç—ã —Å–º–æ–∂–µ—à—å:
‚ú® –ü–æ–ª—É—á–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∫–µ–π—Å—ã, —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ò–ò.
‚ú® –ü—Ä–µ–¥–ª–∞–≥–∞—Ç—å —Å–≤–æ–∏ —Ä–µ—à–µ–Ω–∏—è.
‚ú® –ü–æ–ª—É—á–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω—É—é –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å.
‚ú® –û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —Å–≤–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å.

–ì–æ—Ç–æ–≤ –Ω–∞—á–∞—Ç—å –æ—Ç—Ç–∞—á–∏–≤–∞—Ç—å –º–∞—Å—Ç–µ—Ä—Å—Ç–≤–æ?
"""

EXPLANATION_TEXT = """üìù –ö–∞–∫ –≤—Å–µ —É—Å—Ç—Ä–æ–µ–Ω–æ:

1Ô∏è‚É£ –¢—ã –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—à—å –Ω–æ–≤—ã–π –∫–µ–π—Å.
2Ô∏è‚É£ –í–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ –∏–∑—É—á–∞–µ—à—å –æ–ø–∏—Å–∞–Ω–∏–µ —Å–∏—Ç—É–∞—Ü–∏–∏ –∫–ª–∏–µ–Ω—Ç–∞.
3Ô∏è‚É£ –§–æ—Ä–º—É–ª–∏—Ä—É–µ—à—å –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—à—å —Å–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ –∏–ª–∏ –ø–ª–∞–Ω —Ç–µ—Ä–∞–ø–∏–∏.
4Ô∏è‚É£ –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ç–≤–æ–π –æ—Ç–≤–µ—Ç –∏ –¥–∞–µ—Ç —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—É—é –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å, –ø–æ–¥—Å–≤–µ—á–∏–≤–∞—è —Å–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã –∏ –∑–æ–Ω—ã —Ä–æ—Å—Ç–∞.

–≠—Ç–æ –æ—Ç–ª–∏—á–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–∞–∫—Ç–∏–∫–æ–≤–∞—Ç—å—Å—è –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ–π —Å—Ä–µ–¥–µ –∏ –ø–æ–ª—É—á–∞—Ç—å –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–º–µ—á–∞–Ω–∏—è –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Ç–≤–æ–∏—Ö –Ω–∞–≤—ã–∫–æ–≤!
"""

TRIAL_OFFER_TEXT = """üöÄ –û—Ç–ª–∏—á–Ω–æ!

–ß—Ç–æ–±—ã —Ç—ã –º–æ–≥ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ –æ—Ü–µ–Ω–∏—Ç—å –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏, –º—ã –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º —Ç–µ–±–µ –Ω–∞—á–∞—Ç—å —Å <b>–±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ 7-–¥–Ω–µ–≤–Ω–æ–≥–æ –ø—Ä–æ–±–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞</b>.
–í —Ç–µ—á–µ–Ω–∏–µ –Ω–µ–¥–µ–ª–∏ —Ç–µ–±–µ –±—É–¥—É—Ç –¥–æ—Å—Ç—É–ø–Ω—ã –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ—Ç–∞ –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π.

–ü–æ—Å–ª–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è –ø—Ä–æ–±–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞ —Ç—ã —Å–º–æ–∂–µ—à—å –≤—ã–±—Ä–∞—Ç—å –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Ç–∞—Ä–∏—Ñ –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –ø—Ä–∞–∫—Ç–∏–∫–∏.
"""

TRIAL_STARTED_TEXT = """üéâ –¢–≤–æ–π 7-–¥–Ω–µ–≤–Ω—ã–π –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –ø—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –Ω–∞—á–∞–ª—Å—è! ({start_date} - {end_date})

–¢–µ–ø–µ—Ä—å —Ç–µ–±–µ –¥–æ—Å—Ç—É–ø–Ω—ã –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ—Ç–∞. –ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å."""
WELCOME_BACK_TEXT = """üëã –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º! –†–∞–¥ —Å–Ω–æ–≤–∞ —Ç–µ–±—è –≤–∏–¥–µ—Ç—å."""
HELP_TEXT = """üëã <b>–†–∞–∑–¥–µ–ª –ü–æ–º–æ—â–∏</b>

–î–∞–≤–∞–π—Ç–µ –±—ã—Å—Ç—Ä–æ –ø—Ä–æ–±–µ–∂–∏–º—Å—è –ø–æ –æ—Å–Ω–æ–≤–Ω—ã–º —Ñ—É–Ω–∫—Ü–∏—è–º:

üé≤ <b>–ù–æ–≤—ã–π –∫–µ–π—Å</b> - –ü–æ–ª—É—á–∏—Ç—å —Å–≤–µ–∂–∏–π —Ç–µ—Ä–∞–ø–µ–≤—Ç–∏—á–µ—Å–∫–∏–π —Å–ª—É—á–∞–π –¥–ª—è —Ä–∞–∑–±–æ—Ä–∞ –∏ –ø—Ä–∞–∫—Ç–∏–∫–∏!

üìä <b>–ú–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å</b> - –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤–∞—à—É —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É!

üí¨ <b>–û—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤</b> - –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –º—ã—Å–ª—è–º–∏ –æ –±–æ—Ç–µ, –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é –∏–ª–∏ —Å–æ–æ–±—â–∏—Ç—å –æ –Ω–µ–ø–æ–ª–∞–¥–∫–µ!

üí≥ <b>–¢–∞—Ä–∏—Ñ—ã –∏ –ø–æ–¥–ø–∏—Å–∫–∞</b> - –£–∑–Ω–∞—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ç–∞—Ä–∏—Ñ—ã!


"""
PROFILE_TEXT = """üë§ –í–∞—à –ø—Ä–æ—Ñ–∏–ª—å:

Telegram ID: {user_id}
–†–æ–ª—å: {role}
–°—Ç–∞—Ç—É—Å –ø–æ–¥–ø–∏—Å–∫–∏: {subscription_status}
–ü—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –¥–æ: {trial_end_date_str}
–ü–æ–¥–ø–∏—Å–∫–∞ –¥–æ: {subscription_expires_at_str}"""

@user_onboarding_router.message(CommandStart())
async def handle_start(message: types.Message, session: AsyncSession, state: FSMContext):
    user = message.from_user
    current_state_data = await state.get_data()
    last_menu_msg_id = current_state_data.get("last_menu_msg_id")

    if last_menu_msg_id:
        try:
            await message.bot.delete_message(chat_id=message.chat.id, message_id=last_menu_msg_id)
            logger.info(f"Deleted previous menu message {last_menu_msg_id} for user {user.id} during /start")
        except Exception as e:
            logger.warning(f"Could not delete previous menu message {last_menu_msg_id} for user {user.id} during /start: {e}")

    await state.clear()
    db_user = await user_crud.get_user_by_telegram_id(session, telegram_id=user.id)

    current_time = datetime.now(timezone.utc)
    user_data_for_create_or_update = {
        "username": user.username,
        "first_name": user.first_name,
        "last_name": user.last_name,
        "last_seen": current_time,
    }

    if not db_user:
        db_user = await user_crud.create_user(
            session,
            telegram_id=user.id,
            role=UserRole.USER,
            subscription_status=SubscriptionStatus.NONE,
            **user_data_for_create_or_update
        )
        logger.info(f"New user {db_user.telegram_id} created. Starting onboarding.")
        await message.answer(WELCOME_TEXT, reply_markup=get_onboarding_welcome_keyboard())
        return
    else:
        update_payload = {
            "username": user.username,
            "first_name": user.first_name,
            "last_name": user.last_name,
            "last_active_at": current_time
        }
        db_user = await user_crud.update_user(session, telegram_id=db_user.telegram_id, update_data=update_payload)
        if not db_user:
             logger.error(f"Failed to update existing user {user.id}")
             await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
             return
        logger.info(f"User {db_user.telegram_id} exists. Activity updated.")

    if db_user.is_blocked:
        await message.answer("–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        logger.warning(f"Blocked user {user.id} tried to use /start.")
        return

    trial_active = db_user.subscription_status == SubscriptionStatus.TRIAL and db_user.trial_end_date and db_user.trial_end_date > current_time
    subscription_active = db_user.subscription_status == SubscriptionStatus.ACTIVE and db_user.subscription_expires_at and db_user.subscription_expires_at > current_time
    trial_was_ever_used = db_user.trial_start_date is not None
    
    if not trial_active and not subscription_active:
        if trial_was_ever_used:
            # Trial was used and is not currently active, and no active subscription
            logger.info(f"User {db_user.telegram_id} has no active sub/trial, but trial was used before. Guiding to /menu.")
            menu_msg = await message.answer(
                "–ü—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥ —É–∂–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω. –í—ã –º–æ–∂–µ—Ç–µ –≤—ã–±—Ä–∞—Ç—å –ø–ª–∞—Ç–Ω—ã–π —Ç–∞—Ä–∏—Ñ –∏–ª–∏ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥—Ä—É–≥–∏–µ –æ–ø—Ü–∏–∏ –≤ –º–µ–Ω—é.", 
                reply_markup=get_main_inline_menu_keyboard()
            )
            await state.update_data(last_menu_msg_id=menu_msg.message_id)
        else:
            # No active trial, no active subscription, and trial was never used
            logger.info(f"User {db_user.telegram_id} has no active sub/trial and trial never used. Starting onboarding flow.")
            await message.answer(WELCOME_TEXT, reply_markup=get_onboarding_welcome_keyboard())
    else:
        # User has an active trial or active subscription
        logger.info(f"User {db_user.telegram_id} has active sub/trial. Sending to main menu (inline).")
        menu_msg = await message.answer(WELCOME_BACK_TEXT, reply_markup=get_main_inline_menu_keyboard())
        await state.update_data(last_menu_msg_id=menu_msg.message_id)

@user_onboarding_router.callback_query(OnboardingCallback.filter(F.action == "tell_me_more"))
async def cq_onboarding_tell_me_more(query: types.CallbackQuery, callback_data: OnboardingCallback, session: AsyncSession):
    await query.message.edit_text(EXPLANATION_TEXT, reply_markup=get_onboarding_explanation_keyboard())
    await query.answer()

@user_onboarding_router.callback_query(OnboardingCallback.filter(F.action == "how_to_start"))
async def cq_onboarding_how_to_start(query: types.CallbackQuery, callback_data: OnboardingCallback, session: AsyncSession):
    await query.message.edit_text(TRIAL_OFFER_TEXT, reply_markup=get_onboarding_trial_offer_keyboard())
    await query.answer()

@user_onboarding_router.callback_query(OnboardingCallback.filter(F.action == "start_trial"))
async def cq_onboarding_start_trial(query: types.CallbackQuery, callback_data: OnboardingCallback, session: AsyncSession):
    telegram_user_id = query.from_user.id
    db_user = await user_crud.get_user_by_telegram_id(session, telegram_id=telegram_user_id)
    current_time = datetime.now(timezone.utc)

    if not db_user:
        logger.error(f"User {telegram_user_id} not found in DB during start_trial callback.")
        await query.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ /start —Å–Ω–æ–≤–∞.", show_alert=True)
        return

    has_active_subscription = db_user.subscription_status == SubscriptionStatus.ACTIVE and \
                              db_user.subscription_expires_at and \
                              db_user.subscription_expires_at > current_time
    
    trial_was_used = db_user.trial_start_date is not None

    if has_active_subscription or trial_was_used:
        message_text = "–ü–æ—Ö–æ–∂–µ, —É –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞." if has_active_subscription else "–ü–æ—Ö–æ–∂–µ, –≤—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –ø—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥."
        logger.info(f"User {db_user.telegram_id} tried to start trial but: active_sub={has_active_subscription}, trial_used={trial_was_used}.")
        await query.message.edit_text(message_text, reply_markup=None)
        await query.message.answer(f"–í–æ—Ç –≤–∞—à–µ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é, {hbold(query.from_user.first_name or '')}!", reply_markup=get_main_menu_keyboard(user_role=db_user.role))
        await query.answer()
        return

    trial_starts_at = current_time
    trial_expires_at = trial_starts_at + timedelta(days=settings.TRIAL_PERIOD_DAYS)
    
    updated_user_data = {
        "subscription_status": SubscriptionStatus.TRIAL,
        "trial_start_date": trial_starts_at,
        "trial_end_date": trial_expires_at,
        "last_active_at": current_time
    }
    updated_user = await user_crud.update_user(
        session,
        telegram_id=db_user.telegram_id, 
        update_data=updated_user_data
    )

    if updated_user:
        start_date_str = trial_starts_at.strftime("%d.%m.%Y")
        end_date_str = trial_expires_at.strftime("%d.%m.%Y")
        logger.info(f"User {updated_user.telegram_id} started trial period until {end_date_str}.")
        
        await query.message.edit_text(
            TRIAL_STARTED_TEXT.format(start_date=start_date_str, end_date=end_date_str),
            reply_markup=None 
        )
        edited_menu_msg = await query.message.edit_text( 
            f"–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {hbold(updated_user.first_name or '')}! –í–∞—à –ø—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –∞–∫—Ç–∏–≤–µ–Ω.", 
            reply_markup=get_main_inline_menu_keyboard()
        )
        await state.update_data(last_menu_msg_id=edited_menu_msg.message_id)
        logger.info(f"Updated last_menu_msg_id to {edited_menu_msg.message_id} after trial activation menu for user {updated_user.telegram_id}")
    else:
        logger.error(f"Failed to update user {db_user.telegram_id} to start trial period via update_user.")
        await query.message.edit_text("–ù–µ —É–¥–∞–ª–æ—Å—å –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.")
    
    await query.answer()

@user_onboarding_router.message(Command("help"))
@user_onboarding_router.message(F.text == "‚ÑπÔ∏è –ü–æ–º–æ—â—å")
async def handle_help_command(message: types.Message, state: FSMContext):
    await state.clear()
    await message.answer(HELP_TEXT, disable_web_page_preview=True, parse_mode='HTML')

@user_onboarding_router.message(Command("profile"))
async def handle_profile_command(message: types.Message, session: AsyncSession, state: FSMContext):
    await state.clear()
    telegram_user_id = message.from_user.id
    db_user = await user_crud.get_user_by_telegram_id(session, telegram_id=telegram_user_id)
    if db_user:
        trial_end_str = db_user.trial_end_date.strftime('%d.%m.%Y') if db_user.trial_end_date else '–Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è'
        sub_expires_str = db_user.subscription_expires_at.strftime('%d.%m.%Y') if db_user.subscription_expires_at else '–Ω–µ—Ç'
        status_description = "–ù–µ—Ç –ø–æ–¥–ø–∏—Å–∫–∏"
        if db_user.subscription_status == SubscriptionStatus.TRIAL:
            status_description = f"–ü—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥ (–¥–æ {trial_end_str})"
        elif db_user.subscription_status == SubscriptionStatus.ACTIVE:
            status_description = f"–ê–∫—Ç–∏–≤–Ω–∞ (–¥–æ {sub_expires_str})"
        elif db_user.subscription_status == SubscriptionStatus.EXPIRED:
            status_description = "–ò—Å—Ç–µ–∫–ª–∞"
            if db_user.subscription_expires_at:
                status_description += f" ({db_user.subscription_expires_at.strftime('%d.%m.%Y')})"
        role_map = {
            UserRole.USER: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å",
            UserRole.ADMIN: "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä"
        }
        profile_info = PROFILE_TEXT.format(
            user_id=db_user.telegram_id,
            role=role_map.get(db_user.role, str(db_user.role)),
            subscription_status=status_description,
            trial_end_date_str=trial_end_str,
            subscription_expires_at_str=sub_expires_str
        )
        await message.answer(profile_info)
    else:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≤–∞—à –ø—Ä–æ—Ñ–∏–ª—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start")

@user_onboarding_router.message(Command("menu"))
async def handle_menu_command(message: types.Message, session: AsyncSession, state: FSMContext):
    user_id = message.from_user.id
    current_state_data = await state.get_data()
    last_menu_msg_id = current_state_data.get("last_menu_msg_id")

    if last_menu_msg_id:
        try:
            await message.bot.delete_message(chat_id=message.chat.id, message_id=last_menu_msg_id)
            logger.info(f"Deleted previous menu message {last_menu_msg_id} for user {user_id}")
        except Exception as e:
            logger.warning(f"Could not delete previous menu message {last_menu_msg_id} for user {user_id}: {e}")
    
    await state.clear()

    db_user = await user_crud.get_user_by_telegram_id(session, telegram_id=user_id)
    if not db_user:
        await message.answer("–ü–æ—Ö–æ–∂–µ, –≤—ã –µ—â–µ –Ω–µ –Ω–∞—á–∞–ª–∏ –¥–∏–∞–ª–æ–≥ —Å–æ –º–Ω–æ–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start.")
        return
    if db_user.is_blocked:
        await message.answer("–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.")
        return
    
    await message.delete()
    new_menu_msg = await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é –∏–∑ –º–µ–Ω—é:", reply_markup=get_main_inline_menu_keyboard())
    await state.update_data(last_menu_msg_id=new_menu_msg.message_id)
    logger.info(f"Sent new menu {new_menu_msg.message_id} for user {user_id} and updated last_menu_msg_id.")

@user_onboarding_router.callback_query(F.data == "main_menu:show")
async def cq_show_main_menu(query: types.CallbackQuery, session: AsyncSession, state: FSMContext):
    current_fsm_state = await state.get_state()
    if current_fsm_state == FeedbackStates.awaiting_feedback_text.state:
        await state.clear()
        logger.info(f"User {query.from_user.id} went back to main menu, cleared FeedbackStates.awaiting_feedback_text state.")

    await query.message.edit_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é –∏–∑ –º–µ–Ω—é:", 
        reply_markup=get_main_inline_menu_keyboard()
    )
    await state.update_data(last_menu_msg_id=query.message.message_id)
    await query.answer()

@user_onboarding_router.callback_query(F.data == "main_menu:support_email")
async def cq_support_email(query: types.CallbackQuery, session: AsyncSession):
    processed_email = ""
    if settings.SUPPORT_EMAIL:
        email_value = str(settings.SUPPORT_EMAIL).strip()
        if (email_value.startswith('"') and email_value.endswith('"')) or \
           (email_value.startswith("'") and email_value.endswith("'")):
            email_value = email_value[1:-1]
        processed_email = email_value.strip()

    if processed_email and "@" in processed_email and "." in processed_email.split("@",1)[-1]:
        email_link = hlink(processed_email, f"mailto:{processed_email}")
        await query.message.edit_text(
            f"–î–ª—è —Å–≤—è–∑–∏ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞—à—É –ø–æ—á—Ç—É <b>{email_link}</b>. \n–ú—ã –ø–æ—Å—Ç–∞—Ä–∞–µ–º—Å—è –ø–æ–º–æ—á—å –≤–∞–º –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ!üßë‚Äçüíª",
            parse_mode=ParseMode.HTML,
            reply_markup=get_back_to_main_menu_keyboard()
        )
    else:
        await query.message.edit_text(
            "üòî –ö–æ–Ω—Ç–∞–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ —É–∫–∞–∑–∞–Ω—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            reply_markup=get_back_to_main_menu_keyboard()
        )
    await query.answer()

@user_onboarding_router.message(Command("support"))
async def handle_support_command(message: types.Message, session: AsyncSession, state: FSMContext):
    user_id = message.from_user.id
    current_state_data = await state.get_data()
    last_menu_msg_id = current_state_data.get("last_menu_msg_id")

    if last_menu_msg_id:
        try:
            await message.bot.delete_message(chat_id=message.chat.id, message_id=last_menu_msg_id)
            logger.info(f"Deleted previous menu message {last_menu_msg_id} for user {user_id} before /support")
        except Exception as e:
            logger.warning(f"Could not delete previous menu message {last_menu_msg_id} for user {user_id} before /support: {e}")

    processed_email = ""
    if settings.SUPPORT_EMAIL:
        email_value = str(settings.SUPPORT_EMAIL).strip()
        if (email_value.startswith('"') and email_value.endswith('"')) or \
           (email_value.startswith("'") and email_value.endswith("'")):
            email_value = email_value[1:-1]
        processed_email = email_value.strip()

    await message.delete()
    if processed_email and "@" in processed_email and "." in processed_email.split("@",1)[-1]:
        email_link = hlink(processed_email, f"mailto:{processed_email}")
        await message.answer(
            f"üìß –î–ª—è —Å–≤—è–∑–∏ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞—à—É –ø–æ—á—Ç—É <b>{email_link}</b>. \n–ú—ã –ø–æ—Å—Ç–∞—Ä–∞–µ–º—Å—è –ø–æ–º–æ—á—å –≤–∞–º –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ!üßë‚Äçüíª",
            parse_mode=ParseMode.HTML,
            reply_markup=get_back_to_main_menu_keyboard()
        )
    else:
        await message.answer(
            "üòî –ö–æ–Ω—Ç–∞–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ —É–∫–∞–∑–∞–Ω—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            reply_markup=get_back_to_main_menu_keyboard()
        )
